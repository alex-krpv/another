//#pragma once
//Задание 1
//Это задание — часть итогового проекта спринта.Вы будете сдавать его на проверку через репозиторий на GitHub.
//Не забудьте сохранить верное решение.
//Реализуйте класс json::Builder, позволяющий сконструировать JSON - объект, используя цепочки вызовов методов.
//Этот класс должен быть основан на уже известной вам библиотеке JSON, данной в заготовке решения.
//
//Начнём с простого примера — объекта - строки:
//json::Builder{}.Value("just a string"s).Build()
//Это выражение должно быть объектом json::Node и содержать указанную строку.
//Вывести построенный JSON, как и раньше, можно так :
//json::Print(
//	json::Document{
//		json::Builder{}
//		.Value("just a string"s)
//		.Build()
//	},
//	cout
//);
//
//Вывод:
//"just a string"
//Более сложный пример демонстрирует все методы builder - класса на более сложном JSON - объекте :
//	json::Print(
//		json::Document{
//			// Форматирование не имеет формального значения:
//			// это просто цепочка вызовов методов
//	json::Builder{}
//	.StartDict()
//		.Key("key1"s).Value(123)
//		.Key("key2"s).Value("value2"s)
//		.Key("key3"s).StartArray()
//			.Value(456)
//			.StartDict().EndDict()
//			.StartDict()
//				.Key(""s).Value(nullptr)
//			.EndDict()
//			.Value(""s)
//		.EndArray()
//	.EndDict()
//	.Build()
//		},
//		cout
//	);
//Вывод:
//{
//	"key1": 123,
//		"key2" : "value2",
//		"key3" : [
//			456,
//			{
//
//			},
//		{
//			"": null
//		},
//				""
//		]
//}
//Разберём все методы класса json::Builder.
//Ниже описана их семантика, и для понимания дан контекст, в котором они вызываются.
//Ошибки неверного использования методов, которые должны обрабатываться в вашей реализации, буду разобраны ниже.
//
//Key(std::string).
//При определении словаря задаёт строковое значение ключа для очередной пары ключ - значение.
//Следующий вызов метода обязательно должен задавать соответствующее этому ключу значение 
//с помощью метода Value или начинать его определение с помощью StartDict или StartArray.
//
//Value(Node::Value).
//Задаёт значение, соответствующее ключу при определении словаря, очередной элемент массива или, 
//если вызвать сразу после конструктора json::Builder, всё содержимое конструируемого JSON - объекта.
//Может принимать как простой объект — число или строку — так и целый массив или словарь.
//Здесь Node::Value — это синоним для базового класса Node, шаблона variant с набором возможных типов - значений.
//Смотрите заготовку кода.
//
//StartDict().
//Начинает определение сложного значения - словаря.Вызывается в тех же контекстах, что и Value.
//Следующим вызовом обязательно должен быть Key или EndDict.
//
//StartArray().
//Начинает определение сложного значения - массива.
//Вызывается в тех же контекстах, что и Value.
//Следующим вызовом обязательно должен быть EndArray или любой, 
//задающий новое значение : Value, StartDict или StartArray.
//
//EndDict().
//Завершает определение сложного значения - словаря.
//Последним незавершённым вызовом Start* должен быть StartDict.
//
//EndArray().
//Завершает определение сложного значения - массива.
//Последним незавершённым вызовом Start* должен быть StartArray.
//
//Build().
//Возвращает объект json::Node, содержащий JSON, описанный предыдущими вызовами методов.
//К этому моменту для каждого Start* должен быть вызван соответствующий End*.
//При этом сам объект должен быть определён, то есть вызов json::Builder{}.Build() недопустим.
//
//Возвращаемое значение каждого метода, кроме Build, должно быть Builder&.
//
//Описанный синтаксис позволяет указывать ключи словаря в определённом порядке.
//Тем не менее, в данном случае это учитывать не нужно.
//Словари всё так же должны храниться с помощью контейнера map.
//
//При реализации обратите внимание на метод emplace_back у вектора: 
//в отличие от push_back он принимает не сам добавляемый объект, 
//а аргументы конструктора этого объекта.Иногда это может быть удобно.
//
//Обработка ошибок
//В случае использования методов в неверном контексте ваш код должен выбросить исключение 
//типа std::logic_error с понятным сообщением об ошибке.
//Это должно происходить в следующих ситуациях :
//
//Вызов метода Build при неготовом описываемом объекте, 
//то есть сразу после конструктора или при незаконченных массивах и словарях.
//
//Вызов любого метода, кроме Build, при готовом объекте.
//
//Вызов метода Key снаружи словаря или сразу после другого Key.
//
//Вызов Value, StartDict или StartArray где - либо, кроме как после конструктора, 
//после Key или после предыдущего элемента массива.
//
//Вызов EndDict или EndArray в контексте другого контейнера.
//
//Ограничения
//Методы класса должны иметь амортизированную линейную сложность относительно размера входных данных.
//Исключение — дополнительный логарифмический множитель при добавлении в словарь.
//Принимайте тяжёлые объекты в методах таким образом, 
//чтобы при вызове этих методов объекты можно было переместить.
//Например, принимайте по значению и перемещайте в коде метода.
//
//Что отправлять на проверку
//
//Файлы json.h, json.cpp, json_builder.h и json_builder.cpp, содержащие:
//Библиотеку для работы с JSON, данную в заготовке.Вы можете вносить в неё косметические изменения.
//Класс json::Builder, описанный выше.
//Как будет тестироваться ваш код
//Работоспособность кода и его соответствие указанным выше требованиям 
//будет проверена юнит - тестами, подобным примерам выше.
//Гарантируется, что не будет создаваться переменная типа json::Builder : 
//сразу после конструирования этот объект будет цепочкой методов, 
//оканчивающейся на Build, преобразовываться в json::Node.

//Проверка ошибок:
//Правило1 - Непосредственно после Key вызван не Value, не StartDict и не StartArray
//json::Builder{}.StartDict().Key("key1"s).Key("key3"s);
//json::Builder{}.StartDict().Key("key1"s).EndDict();
//json::Builder{}.StartDict().Key("key1"s).EndArray();

//Правило2 - после вызова Value, последовавшего за вызовом Key, вызван не Key и не EndDict
//json::Builder{}.StartDict().Key("key1"s).Value(123).Value(123);
//json::Builder{}.StartDict().Key("key1"s).Value(123).Build();
//json::Builder{}.StartDict().Key("key1"s).Value(123).StartArray();

//Правило3 - за вызовом StartDict следует не Key и не EndDict
//json::Builder{}.StartDict().Build();
//json::Builder{}.StartDict().Value(123);
//json::Builder{}.StartDict().StartArray();

//Правило4 - за вызовом StartArray следует не Value, не StartArray, не StartDict и не EndArray
//json::Builder{}.StartArray().Key("key1"s);
//json::Builder{}.StartArray().EndDict();

//Правило5 - за вызовом StartArray и серии Value следует не Value, не StartArray, не StartDict и не EndArray
//json::Builder{}.StartArray().Value(123).Value(123).Key("key1"s);
//json::Builder{}.StartArray().Value(123).Value(123).EndDict();
//json::Builder{}.StartArray().Value(123).Value(123).Build();

//Подсказка

//Мы рекомендуем хранить в объекте json::Builder следующее состояние :
//Node root_; — сам конструируемый объект.
//std::vector<Node*> nodes_stack_; — стек указателей на те вершины JSON, 
//которые ещё не построены : то есть текущее описываемое значение и цепочка его родителей.
//Он поможет возвращаться в нужный контекст после вызова End - методов.
//Начните проектирование кода с описания ожидаемого состояния класса
//(в первую очередь — последней вершины в стеке) для каждой точки в цепочке вызовов в примере.




//В конструкторе по умолчанию Builder сразу в стек(вектор указателей на Ноды) положите указатель на root.
//И вся дальнейшая работа сводится как раз с работой с back() у вектора указателей а также добавлением и удалением в вектор элементов.
//Для того, чтобы можно было модифицировать ноду, 
//нужно в класс Json добавить не константную версию методы GetNode.
//При команде StartArray смотрите что именно находится на вершине стека - если, 
//например там nullptr (а это соответствует самому началу работы - когда в стеке 
//только указатель на root и в root никакого значения нет) - if (hold_alternative<nullptr>(stack.back()))
//- то просто присваиваем stack_back()->GetValue() = Array{};
//Если команда EndArray - то проверяем, на вершине стека точно лежит Array ? 
//если да - то удаляем ноду с вершина стека(stack.pop_back()), иначе - ошибка logick_error.
//Таким образом все манипуляции с указателями на стеке привели к тому, 
//что значение в root изменилось и стало равно пустому массиву(Array{}) - и сам стек оказался пуст.
//Поэтому вызов метода Build() не должен выдавать ошибок в такой ситуации.

//Никаких новых builder создавать не надо. 
//Новый массив (словарь) можно добавлять используя StartArray - StartDict в двух случаях : 
//1)когда на вершине nullptr  - тогда по схеме что я описал выше нужно делать 
//(замечу, что nullptr на вершине стека будет и в том случае, если на добавляется value в уже имеющийся dict[key]), 

//2)если на  вершине стеке уже Array - тогда нужно в имеющийся массив просто добавить новый элемент, 
//а в стек поместить указатель на этот добавленный элемент.



//json::Builder{}.Value("s"s).Key("1"s).Build()
//json::Builder{}.Value("s"s).Value("1"s).Build()
//json::Builder{}.Value("s"s).StartDict().Build()
//json::Builder{}.Value("s"s).StartArray().Build()
//json::Builder{}.Value("s"s).EndDict().Build()
//json::Builder{}.Value("s"s).EndArray().Build()

