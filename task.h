//Задание
//Вам поступил заказ на разработку дизайна базы данных документов, 
//удостоверяющих личность. 
//Заказчик — компания «ПИН: полиморфизм, инкапсуляция, наследование». 
//Вы занялись разработкой исходя из требований. 
//В базе должны быть реализованы классы для паспорта, водительских прав, 
//международных водительских прав, набора путешественника и 
//общий класс идентификационных документов. 
//В самые короткие сроки вы подготовили первый вариант. 
//Но в это же время в совете директоров случились изменения. 
//Один из совладельцев ушёл из компании и оставил за собой права на 
//использование слова «наследование» в названии. 
//Теперь компания называется «ПИ: полиморфизм, инкапсуляция». 
//Компания не хочет иметь ничего общего с предыдущим названием, 
//поэтому просит вас избавиться от наследования в вашем коде. 
//При этом весь функционал должен сохраниться.
//Нужно реализовать наследование без использования наследования. 
//Пригодятся ваши знания о том, как устроены объекты. 
//Добавьте самостоятельно все нужные виртуальные функции и указатели на них, 
//чтобы сохранить полиморфизм.
//Вы предупредили заказчика, что придётся пользоваться грязными приёмами, 
//такими как reinterpret_cast или С-style конвертация. 
//Заказчик готов на всё, лишь бы вы решили его проблему.
//
//Ограничения
//
//Не используйте наследование и виртуальные методы.
//Не нужно реализовывать возможность удаления объектов, созданных с помощью new [].
//Что отправлять на проверку
//Файлы identity_document.h, passport.h, driving_licence.h, 
//international_driving_licence.h и travel_pack.h, 
//содержащие переработанную версию классов идентификационных документов.
//Как будет тестироваться ваш код
//Заказчик проверит, что ваша программа выводит на экран то же, 
//что выводила до запрета наследования. 
//Часть тестов вам дали для самопроверки, 
//а другую часть компания будет запускать в закрытом тестировании.
//В файле main_original.cpp лежат тесты компании, написанные до запрета наследования. 
//В файле main.cpp лежат тесты, отредактированные уже после введения запрета. 
//Для корректной реализации удаления объектов, созданных через new, 
//в переработанных тестах уже подставлен вызов метода Delete, 
//реализацию которого вам тоже нужно написать.
//Наличие наследования в коде будет проверяться поиском ключевого слова virtual.

//ПОДСКАЗКА

//Возможно, нужно добавить кастомную конвертацию типов...
//Порядок действий в конструкторе :
//Сконструировать базовый объект;
//Сконструировать другие необходимые поля;
//Установить указатель vtable на таблицу своего типа;
//Сделать остальные действия(например, печать на экран);
//
//Порядок действий при вызове деструктора :
//Просто удаляем объект и не химичим, положась на компилятор;
//Если объект наследуемого класса, то не забыть переставить указатель vtable 
//на виртуальную таблицу базового класса.
//
//При удалении методом Delete :
//Вызвать виртуальный Delete из таблицы виртуальных методов;
//И только в нём удалить объект, вызвав по радио связного с позывными Гусь - Гусь.
//
//При вызове конструктора копирования :
//Не забыть установить указатель vtable на ...
//И дальше неразборчиво.


//Из пачки

//Методы и их реализация, характерные для класса - наследника, 
//а также переопределённые методы, 
//должны храниться как static void в private области класса.
//В public находятся не static методы, 
//которые вызывают соответствующие функции из vtable объекта.
//Если эти условия соблюдены и работа с vtable родителя и наследника 
//построена корректно(при получении виртуальной таблицы объекта класса 
//берётся виртуальная таблица identity_doc_, 
//приведённая по типу к виртуальной таблице текущего класса), 
//проблема с multiple definition должна решиться.


//ВОПРОС:
//Подскажите, не совсем понимаю как настроить в классах корректное 
//использование виртуальной таблицы.
//Как я понял базовый класс хранит ссылку на vtable, 
//а классы наследники хранят в себе объект базового класса.
//Метод любого класса(например PrintID) вызывает функции из vtable, 
//которые в свою очередь вызывают статические методы из private области класса? 
//Если так, то тогда чтобы обращаться к его переменным в статический метод
//должна быть передана ссылка на текущий объект получается.
//Я пытался реализовать таблицу как отдельный класс, 
//потом пробовал как массив указателей на функции(как то так - void (vpointer_[2])(void);).
//Ну и естественно на втором тесте где происходит(IdentityDocument)(new Passport()) 
//и вызов метода PrintID() я ловлю исключение когда пытаюсь приведенный к(void) this  
//отправить в функцию.
//Мне кажется я куда то не туда уже залез, и все должно быть как то проще)
//ОТВЕТ:
//У базового класса есть своя виртуальная таблица, которая неизменна(static vtable), 
//и у наследников точно так же есть свои собственные виртуальные таблицы, тоже неизменные.
//
//И от базового класса, и от наследников нужно как - то получать виртуальную таблицу
//(например, с помощью метода в каждом классе), 
//тогда получится эффективно передавать нужную таблицу.
//
//Реализация vtable примерно в правильно направлении - это отдельный класс или структура 
//внутри текущего класса, а в качестве параметров у данного класса - указатели на функции
//(отдельный параметр для каждой функции).
//
//Можно реализовать operator IdentityDocument() для ситуаций с приведениями типов, 
//это должно решить проблему с исключением.:)